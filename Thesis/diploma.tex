% Тут используется класс, установленный на сервере Papeeria. На случай, если
% текст понадобится редактировать где-то в другом месте, рядом лежит файл matmex-diploma-custom.cls
% который в момент своего создания был идентичен классу, установленному на сервере.
% Для того, чтобы им воспользоваться, замените matmex-diploma на matmex-diploma-custom
% Если вы работаете исключительно в Papeeria то мы настоятельно рекомендуем пользоваться
% классом matmex-diploma, поскольку он будет автоматически обновляться по мере внесения корректив
%
\documentclass{matmex-diploma}
\usepackage{amssymb}
\begin{document}
% Год, город, название университета и факультета предопределены,
% но можно и поменять.
% Если англоязычная титульная страница не нужна, то ее можно просто удалить.
\filltitle{ru}{
    chair              = {Кафедра Информационных Систем},
    title              = {Реализация эффективного выполнения поисковых запросов по множеству полей для колоночно-ориентированной базы данных, хранящейся в памяти.},
    % Здесь указывается тип работы. Возможные значения:
    %   coursework - Курсовая работа
    %   diploma - Диплом специалиста
    %   master - Диплом магистра
    %   bachelor - Диплом бакалавра
    type               = {bachelor},
    position           = {студента},
    group              = 4501,
    author             = {Жаворонков Эдгар Андреевич},
    %supervisorPosition = {д.\,ф.-м.\,н., профессор},
    supervisor         = {Дельгядо Ф.\,И.},
    %reviewerPosition   = {},
    %reviewer           = {},
    chairHeadPosition  = {д.\,т.\,н., профессор},
    chairHead          = {Парфенов В.\,Г.},
    university         = {Санкт-Петербургский Национальный Исследовательский Университет Информационных Технологий, Механики и Оптики},
    faculty            = {Факультет Информационных Технологий и Программирования},
    city               = {Санкт-Петербург},
    year               = {2015}
}
\maketitle
\tableofcontents
% У введения нет номера главы
\section*{Введение. Описание предметной области}

\subsection{Краткая история колоночно-ориентированных баз данных}
    Колоночно-ориентированные системы управления базами данных берут свое начало в 70-ых годах прошлого столетия. Так называемая TOD (Time Oriented Database) была предназначена для управления медицинскими записями. Одна из ранних систем, напоминающих современные колоночно-ориентированные СУБД была Cantor, которая, кроме всего прочего, включала в себя обильное использование различных техник сжатия данных (RLE - Run Length Encoding, сжатие числовых данных и т.д). Дальнейшее развитие привело к появлению на свет Sybase IQ, показавшей преимущества колоночно-ориентированного хранения данных для аналитических приложений. В середине 2000-ых годов, в связи с увеличением производительности аппаратного обеспечения, произошел резкий скачок в развитии колоночно-ориентированных хранилищ. На свет появились Vertica, Ingres, VectorWise, Paraccel и др. В дальнейшем, это привело к тому, что многие большие разработчики традиционных реляционных БД (такие как Oracle, Microsoft, IBM и др.) добавили поддержку хранения данных по колонкам.

\subsection{Описание архитектуры}
    Главное отличие колоночно-ориентированных баз данных, от традиционных - это физический способ хранения данных. Традиционные базы хранятся построчно, то есть все строки таблицы представлены в виде одной большой физической записи, в которой поля идут одно за другим. %картинку!
    Плюсы такого подхода к хранению данных:
    \begin{enumerate}\itemsep1pt \parskip0pt \parsep0pt
        \item Быстрое добавление новых строк в таблицу
        \item Быстрая выборка строки по ключу
        \item Быстрая выборка всех строк
    \end{enumerate}
    Минусы:
    \begin{enumerate}\itemsep1pt \parskip0pt \parsep0pt
        \item Большое количество различных индексов, журналов - избыточность информации
        \item Медленная выборка нескольких колонок
        \item Медленная вставка новой колонки
    \end{enumerate}
    %картинку!
    Рассмотрим подробнее второй недостаток. Представим себе базу данных, состоящую из одной таблицы на 50 колонок. Предположим, что нам нужно выбрать из нее лишь три. Но тогда, так как она хранится построчно, то значения всех полей будут считаны с диска, затем ненужные данные будут отброшены. Получение этой выборки произойдет за время равное $O(m * n)$, где $m$ - это количество строк, а $n$ - количество колонок. При большом количестве строк в такой базе, получение выборки по нескольким критериям - довольно дорогая операция, особенно с учетом ограничений дисковых интерфейсов ввода-вывода.
    
    Колоночно-ориентированные базы данных хранят записи по колонкам, друг за другом.  Очевидны плюсы такого формата хранения данных: % тоже картинку!
    \begin{enumerate}\itemsep1pt \parskip0pt \parsep0pt
        \item Возможность сжатия данных
        \item Быстрая вставка новой колонки или изменение значений в существующей
        \item Быстрая выборка нескольких колонок
    \end{enumerate}
    Но есть и минусы:
    \begin{enumerate}\itemsep1pt \parskip0pt \parsep0pt
        \item Добавление новой строки - очень медленная операция
        \item Как, впрочем, и изменение существующей
    \end{enumerate}
\subsection{Решаемые задачи}
    Из плюсов и минусов колоночно-ориентированных баз напрямую следуют задачи, которые они призваны решать. Как я уже упоминал в истории развития, такой подход к хранению данных хорош для аналитических приложений, в которых основная нагрузка создается выборкой больших объемов данных по нескольким критериям(как правило, 7 или 8). Либо же, задача многокритериального поиска, в которой, опять же, основная нагрузка - выборка большого объема данных по нескольким полям, но без какой-либо аналитики.  %воды, больше воды!
\section{Обзор аналогов}
    %Vertica, VoltDB, SybaseIQ - а что вообще писать????
    Ближайшие по архитектуре СУБД - это TimesTen by Oracle, VoltDB, SAP HANA. Все три используют хранение данных по колонкам, являются in-memory и предназначены для аналитических задач. Однако, их объединяет один общий недостаток - цена. Полные версии всех трех СУБД стоят больше десяти тысяч USD.
    
    Существует бесплатный вариант in-memory SQL базы данных - H2. Однако, он не колоночно-ориентирован и медленно работает на сложных операциях JOIN.
    
    Два решения, пригодных для решения задачи многокритериального поиска - это MySQL и Lucene. Вообще говоря, основное предназначение Apache Lucene - это полнотекстовый поиск, однако им можно пользоваться и как in-memory БД для поиска по нескольким критериям  Недостаток Lucene - очень медленная операция commit. MySQL - ??? 
\section{Требования к разрабатываемому компоненту}
%это вообще легитимно?
    Введем в рассмотрение несложную математическую модель. Пусть имеется конечное множество всех атрибутов $A$ и пусть для каждого атрибута имеется множество его допустимых значений - домен $dom(a) : a \in A$. Можно ввести в оборот множество пар $$ Q = \left\{ (a, v) : a \in A, v \in dom(a) \right\} $$
    Тогда поисковым запросов будет являться некоторое подмножество $ q \subset Q $. Временем выполнения запроса назовем отображение $$ t : 2^Q \to \mathbb{R}_{>0} $$
    
    Пусть за время работы движка базы данных к ней было совершено $n$ поисковых запросов $\left\{ q_1, q_2, q_3, ... , q_n \right\} $. Общее время выполнения всех запросов - $$ T = \sum_{i=0}^n t(q_i) $$
    Тогда отношение $B = \frac{n}{T} $ показывает, сколько запросов в единицу времени было выполнено и является аналогом пропускной способности системы. Назовем это отношение эффективностью работы системы. 
    %я ничего не говорю здесь про поток запросов. По-хорошему, надо бы отметить, что запросы идут равномерным потоком(не хочется, чтобы система простаивала). Это палка о двух концах =(
    
    Теперь поймем, каким образом можно максимизировать эффективность. Очевидно, что при увеличении числа запросов нам необходимо уменьшать время выполнения каждого отдельно взятого запроса, тогда отношение будет увеличиваться.

\subsection{Функциональные требования}
    \begin{enumerate}\itemsep1pt \parskip0pt \parsep0pt
        \item Планирование порядка выполнения запроса
        \item Учет сложности запросов к сложным хранилищам (полнотекстовый поиск и т.п.)
        \item Возможность подстройки оптимизатора под конкретное железо
        \item Эффективная реализация выполнения запросов на массированных изменениях данных
    \end{enumerate}
\subsection{Формальные показатели}
    \begin{enumerate}\itemsep1pt \parskip0pt \parsep0pt 
        \item Увеличение времени выполнения отдельных запросов в два и более раз
    \end{enumerate}
\subsection{Нефункциональные требования}
    \begin{enumerate}\itemsep1pt \parskip0pt \parsep0pt 
            \item Низкие накладные расходы на обеспечение эффективности выполнения запросов
            \item Тестирование правильности функционирования выполнения запросов
    \end{enumerate}

\section{Постановка задачи}
    %и что еще тут написать?
    Целью данной работы является разработка компонента, позволяющего реализовать эффективное в вышеуказанном контексте выполнение поисковых запросов по нескольким полям. Кроме того, требуется реализовать обеспечение транзакционной целостности данных при сценариях массового обновления данных. 
\section{Обзор архитектуры разрабатываемого компонента}
%Описание виндура, как он работает и что из себя представляет, что и как хранит, как исполняет запросы и так далее. 
    Система управления базами данных Vindur представляет собой хранящееся в оперативной памяти колоночно-ориентированное NoSQL хранилище данных, ориентированное на задачу быстрого поиска по нескольким критериям. Значения каждого атрибута хранятся независимо в специально предназначенных хранилищах. Каждое хранилище ориентировано для выполнения определенного вида запросов(поиск по точному совпадению, поиск на попадание в диапазон, полнотекстовый поиск) к нему.
    
    По своей структуре, хранилище представляет собой набор битовых масок. Результат запроса к хранилищу - битовая маска, единичный бит в $i$-ой позиции означает, что в документе с номером $i$ значение данного атрибута соответствует запросу.
    
    Основная причина, по которой Vindur использует битовые маски - возможность сжатия и быстрое пересечение(оно же логическое И) на современных процессорах. %про сжатие здесь рассказывать или где-то еще?
    
    Основная сущность, в виде которой хранятся все данные в СУБД Vindur - это документ. Документ представляет собой набор атрибутов, каждый из которых имеет одно и более значений. Документ имеет уникальный номер, являющийся его идентификатором внутри движка.
    
    Выполнение поисковых запросов к движку состоит из двух этапов. Сначала запрос проверяется на корректность(как именно?), а затем - получение битовых множеств из хранилищ и их пересечение. Результируещее множество преобразуется в список с номерами документов, удовлетворяющих поисковому запросу. %картинка из презентации

%\section{Описание подходов к решению задачи}
% Для решения задачи оптимального выполнения запросов были предложены следующие три подхода.
% \begin{enumerate}
%     \item Исполнять запрос от начала до конца, не используя никаких оптимизаций. Результат исполнения поискового запроса можно, в таком случае, рассматривать как контрольный, относительно которого можно измерять эффективность и корректность использования последующих решений.
%     \item Исполнять запрос, предварительно упорядочив его части по сложности исполнения каждой отдельно взятой части. На каждом шаге результирующая выборка проверяется на непустоту, что позволяет быстро отсечь запросы, не возвращающие ничего. Кроме того, при небольшом размере результирующей выборки, движок базы данных выполнит оставшиеся части запроса ''вручную'', то есть в обход хранилищ. Основная идея заключается в том, что при небольших результирующих выборках получение информации из хранилища может быть достаточно дорогой операцией, тогда выигрыш по времени можно получить, просто посмотрев значения соответствующих атрибутов у каждого из оставшихся документов. В данном случае, сложность обращения к хранилищу устанавливается эмпирически.
%     \item Аналогично предыдущему пункту исполнять запрос в порядке возрастания сложности обращения к хранилищу, однако сложность считается на основании статистических данных, полученных путем исполнения случайных запросов к хранилищам и измерения среднего времени исполнения для каждого хранилища.
% \end{enumerate}
%\section{Тестирование разрабатываемого компонента}

% У заключения нет номера главы
%\section*{Заключение}

\bibliographystyle{ugost2008ls}
\bibliography{diploma.bib}
\end{document}
