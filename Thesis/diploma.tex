% Тут используется класс, установленный на сервере Papeeria. На случай, если
% текст понадобится редактировать где-то в другом месте, рядом лежит файл matmex-diploma-custom.cls
% который в момент своего создания был идентичен классу, установленному на сервере.
% Для того, чтобы им воспользоваться, замените matmex-diploma на matmex-diploma-custom
% Если вы работаете исключительно в Papeeria то мы настоятельно рекомендуем пользоваться
% классом matmex-diploma, поскольку он будет автоматически обновляться по мере внесения корректив
%
\documentclass{matmex-diploma}
\usepackage{amssymb}
\usepackage{float}
\begin{document}
% Год, город, название университета и факультета предопределены,
% но можно и поменять.
% Если англоязычная титульная страница не нужна, то ее можно просто удалить.
\filltitle{ru}{
    chair              = {Кафедра Информационных Систем},
    title              = {Реализация эффективного выполнения поисковых запросов по множеству полей для колоночно-ориентированной базы данных, хранящейся в памяти.},
    % Здесь указывается тип работы. Возможные значения:
    %   coursework - Курсовая работа
    %   diploma - Диплом специалиста
    %   master - Диплом магистра
    %   bachelor - Диплом бакалавра
    type               = {bachelor},
    position           = {студента},
    group              = 4501,
    author             = {Жаворонков Эдгар Андреевич},
    %supervisorPosition = {д.\,ф.-м.\,н., профессор},
    supervisor         = {Дельгядо Ф.\,И.},
    %reviewerPosition   = {},
    %reviewer           = {},
    chairHeadPosition  = {д.\,т.\,н., профессор},
    chairHead          = {Парфенов В.\,Г.},
    university         = {Санкт-Петербургский Национальный Исследовательский Университет Информационных Технологий, Механики и Оптики},
    faculty            = {Факультет Информационных Технологий и Программирования},
    city               = {Санкт-Петербург},
    year               = {2015}
}
\maketitle
\tableofcontents
% У введения нет номера главы
\section*{Введение}
    \subsection{Краткая история и архитектура колоночно-ориентированных баз данных}
        \paragraph{Историческая справка}
            Колоночно-ориентированные системы управления базами данных берут свое начало в 70-ых годах прошлого столетия. Так называемая TOD (Time Oriented Database) была предназначена для управления медицинскими записями. Одна из ранних систем, напоминающих современные колоночно-ориентированные СУБД была Cantor, которая, кроме всего прочего, включала в себя обильное использование различных техник сжатия данных (RLE - Run Length Encoding, сжатие числовых данных и т.д). Дальнейшее развитие привело к появлению на свет Sybase IQ, показавшей преимущества колоночно-ориентированного хранения данных для аналитических приложений. В середине 2000-ых годов, в связи с увеличением производительности аппаратного обеспечения, произошел резкий скачок в развитии колоночно-ориентированных хранилищ. На свет появились Vertica, Ingres, VectorWise, Paraccel и др. В дальнейшем, это привело к тому, что многие большие разработчики традиционных реляционных БД (такие как Oracle, Microsoft, IBM и др.) добавили поддержку хранения данных по колонкам. \cite{abadidesign}
        \paragraph{Краткое описание архитектуры}
            Главное отличие колоночно-ориентированных баз данных, от традиционных - это физический способ хранения данных. Традиционные базы хранятся построчно, то есть все строки таблицы представлены в виде одной большой физической записи, в которой поля идут одно за другим.
        Плюсы такого подхода к хранению данных:
        \begin{enumerate}\itemsep1pt \parskip0pt \parsep0pt
            \item Быстрое добавление новых строк в таблицу
            \item Быстрая выборка строки по ключу
            \item Быстрая выборка всех строк
        \end{enumerate}
        Минусы:
        \begin{enumerate}\itemsep1pt \parskip0pt \parsep0pt
            \item Большое количество различных индексов, журналов - избыточность информации
            \item Медленная выборка нескольких колонок
            \item Медленная вставка новой колонки
            \item Избыточное хранение данных для полупустых колонок
        \end{enumerate}
        Рассмотрим подробнее второй недостаток. Представим себе базу данных, состоящую из одной таблицы на 50 колонок. Предположим, что нам нужно выбрать из нее лишь три. Но тогда, так как она хранится построчно, то значения всех полей будут считаны с диска, затем ненужные данные будут отброшены. Получение этой выборки произойдет за время равное $O(m * n)$, где $m$ - это количество строк, а $n$ - количество колонок. При большом количестве строк в такой базе, получение выборки по нескольким критериям - довольно дорогая операция, особенно с учетом ограничений дисковых интерфейсов ввода-вывода. \cite{habr:column_db}
        
        \begin{figure}[h]
            \label{row_store}
            \centering
            \includegraphics[width=\textwidth]{../pics/row_store.png}
            \caption{Чтение всех столбцов из строчной БД}
        \end{figure}
        
        \begin{figure}[h]
            \label{column_store}
            \centering
            \includegraphics[width=\textwidth]{../pics/column_store.png}
            \caption{Чтение всех столбцов из колоночной БД}
        \end{figure}
        
        Колоночно-ориентированные базы данных хранят записи по колонкам, друг за другом.  Очевидны плюсы такого формата хранения данных:
        \begin{enumerate}\itemsep1pt \parskip0pt \parsep0pt
            \item Возможность сжатия данных
            \item Быстрая вставка новой колонки или изменение значений в существующей
            \item Быстрая выборка нескольких колонок
        \end{enumerate}
        Но есть и минус:
        \begin{enumerate}\itemsep1pt \parskip0pt \parsep0pt
            \item Изменение нескольких значений в строке происходит медленнее, чем у традиционных БД
        \end{enumerate}
    \paragraph{Решаемые задачи} 
        Из плюсов и минусов колоночно-ориентированных баз напрямую следуют задачи, которые они призваны решать. Как я уже упоминал в истории развития, такой подход к хранению данных хорош для аналитических приложений, в которых основная нагрузка создается выборкой больших объемов данных по нескольким критериям(как правило, 7 или 8). Либо же, задача многокритериального поиска, в которой, опять же, основная нагрузка - выборка большого объема данных по нескольким полям, но без какой-либо аналитики.
        \begin{figure}[h]
            \label{architecture_diff}
            \centering
            \includegraphics[width=\textwidth]{../pics/column-oriented-database1.jpg}
            \caption{Различия в способе хранения данных в традиционных и колоночно-ориентированных БД}
        \end{figure}
    \subsection{Постановка задачи}
        Целью данной работы является разработка компонента для базы данных, предназначенной для эффективной реализации поиска по большому количеству критериев. Подобная база данных может использоваться для большого количества разнообразных задач, в первую очередь для организации поиска по товарам в больших торговых площадках (wikimart.ru - 1.8 млн товаров, Яндекс.Маркет - 57 млн. предложений, amazon.com - 36 млн книг). Для подобных задач характерен поиск по большому количеству критериев (около ста для одного предложения Яндекс.Маркета, двадцати - для amazon.com) и разнообразные принципы поиска по критериям (поиск по диапазону, по совпадению, полнотекстовый поиск). Задача осложняется неравномерным распределением критериев в данных и потенциально большими размером результирующих выборок. При этом, к базе данных предъявляются высокие требования к производительности (как к нагрузке, так и к скорости получения результата) а так же - необходимость обеспечения целостности данных при массовых изменениях значения одного или нескольких критериев.
    \subsection{Требования к разрабатываемому решению}
        \subsubsection{Функциональные требования}
            \begin{enumerate}
                \item Планирование порядка выполнения запроса
                \item Учет сложности запросов к сложным хранилищам (полнотекстовый поиск и т.п.)
                \item Возможность подстройки оптимизатора под конкретное железо
                \item Эффективная реализация выполнения запросов на массированных изменениях данных
            \end{enumerate}
        \subsubsection{Формальные показатели}
            \begin{enumerate}\itemsep1pt \parskip0pt \parsep0pt 
                \item Уменьшение времени выполнения отдельных запросов в два и более раз
            \end{enumerate}
        \subsubsection{Нефункциональные требования}
            \begin{enumerate}\itemsep1pt \parskip0pt \parsep0pt 
                    \item Низкие накладные расходы на обеспечение эффективности выполнения запросов
                    \item Тестирование правильности функционирования выполнения запросов
            \end{enumerate}
    \subsection{Обзор аналогов}
        Ближайшие по архитектуре СУБД - это TimesTen by Oracle, VoltDB, SAP HANA. Все три используют хранение данных по колонкам, являются in-memory и предназначены для аналитических задач. Однако, их объединяет один общий недостаток - цена. Полные версии всех трех СУБД стоят больше десяти тысяч USD.
    
    Существует бесплатный вариант in-memory SQL базы данных - H2. Однако, он не колоночно-ориентирован и медленно работает на сложных операциях JOIN.
    
    Два решения, пригодных для решения задачи многокритериального поиска - это MySQL и Lucene. Вообще говоря, основное предназначение Apache Lucene - это полнотекстовый поиск, однако им можно пользоваться и как in-memory БД для поиска по нескольким критериям  Недостаток Lucene - очень медленная операция commit. Недостатки MySQL - проблемы различных движков (InnoDB и MyISAM) и большое время поиска по нескольким индексам с последующим пересечением результатов. 
    
    \begin{table}[h]
        \centering
        \begin{tabular}{| l | c | c | c | c |}
            \hline
            Product & in-memory & NoSQL & OLAP & Price \\
            \hline
            Oracle TimesTen & \color{green}{\checkmark} & \color{green}{\checkmark} & \color{green}{\checkmark} & \color{red}{€19,969.00} \\
            \hline 
            VoltDB          & \color{green}{\checkmark} & \color{green}{\checkmark} & \color{green}{\checkmark} & \color{red}{\$3500/month} \\
            \hline
            SAP HANA        & \color{green}{\checkmark} & \color{green}{\checkmark} & \color{green}{\checkmark} & \color{red}{\$3595/month}\\
            \hline
        \end{tabular}
        \caption{Сравнительная характеристика TimesTen, VoltDB и SAP HANA}
    \end{table}
    
\section{Описание проектных решений}
    \subsection{Описание системной архитектуры модифицируемого решения}
    %умнее бы их назвать....
    \subsection{Описание тривиального исполнителя запросов}
    \subsection{Описание исполнителя запросов с весами}
    \subsection{Описание автоматически настраивающегося исполнителя}
    \subsection{Описание первого варианта реализации атомарного добавления документа}
    \subsection{Описание второго варианта реализации атомарного добавления документа}
    \subsection{Описание тестовой инфраструктуры}
    
\section{Особенности реализации}
    \subsection{Описание платформы реализации}
    \subsection{Пример реализации SmartExecutor}
    \subsection{Реализация тестовой инфраструктуры}
    \subsection{Результаты тестирования}
    
\section*{Заключение}
    
% \section{Обзор архитектуры разрабатываемого компонента}
% %Описание виндура, как он работает и что из себя представляет, что и как хранит, как исполняет запросы и так далее. 
%     Система управления базами данных Vindur представляет собой хранящееся в оперативной памяти колоночно-ориентированное NoSQL хранилище данных, ориентированное на задачу быстрого поиска по нескольким критериям. Значения каждого атрибута хранятся независимо в специально предназначенных хранилищах. Каждое хранилище ориентировано для выполнения определенного вида запросов(поиск по точному совпадению, поиск на попадание в диапазон, полнотекстовый поиск) к нему.
    
%     По своей структуре, хранилище представляет собой набор битовых масок. Результат запроса к хранилищу - битовая маска, единичный бит в $i$-ой позиции означает, что в документе с номером $i$ значение данного атрибута соответствует запросу.
    
%     Основная причина, по которой Vindur использует битовые маски - возможность сжатия и быстрое пересечение(оно же логическое И) на современных процессорах. %про сжатие здесь рассказывать или где-то еще?
    
%     Основная сущность, в виде которой хранятся все данные в СУБД Vindur - это документ. Документ представляет собой набор атрибутов, каждый из которых имеет одно и более значений. Документ имеет уникальный номер, являющийся его идентификатором внутри движка.
    
%     Выполнение поисковых запросов к движку состоит из двух этапов. Сначала запрос проверяется на корректность, а затем - получение битовых множеств из хранилищ и их пересечение. Результируещее множество преобразуется в список с номерами документов, удовлетворяющих поисковому запросу. 
    
%     \begin{figure}[h]
%         \label{query}
%         \centering
%         \includegraphics[width=0.5\textwidth]{../pics/query.png}
%         \caption{Общая схема выполнения поискового запроса в СУБД Vindur}
%     \end{figure}

% %\section{Тестирование разрабатываемого компонента}

\bibliographystyle{gost780s}
\bibliography{diploma.bib}
\end{document}
